---
title: Customize how changes are displayed
meta:
  title: Display Changes | Tiptap AI change
  description: Customize how AI Changes are displayed in the editor with custom styles and popovers.
  category: Content AI
---

The AI Changes extension is headless and customizable. You have full control over how changed content is displayed in the editor.

## Default change Styles

For each detected change, the AI Changes extension will apply the CSS class `tiptap-ai-changes--old` to the deleted text range, and `tiptap-ai-changes--new` to the inserted text range. The extension does not include any CSS stylesheet. To show the changes in the editor, create a CSS file with these simple styles:

```css
:root {
  --color-green-100: oklch(0.962 0.044 156.743);
  --color-green-700: oklch(0.527 0.154 150.069);
  --color-red-100: oklch(0.936 0.032 17.717);
  --color-red-700: oklch(0.505 0.213 27.518);
}

.tiptap-ai-changes--old,
.tiptap-ai-changes--old > * {
  color: var(--color-red-700);
  background-color: var(--color-red-100);
}

.tiptap-ai-changes--new,
.tiptap-ai-changes--new > * {
  color: var(--color-green-700);
  background-color: var(--color-green-100);
}
```

This will apply a red background to the deleted text, and a green background to the inserted text.

For more advanced styles, use the `getCustomDecorations` [configuration option](/content-ai/capabilities/changes/configure#custom-styles).

## Selected Change

A change is considered "selected" when the selection cursor is over it.

You can retrieve the selected change from the extension's storage object:

```ts
const storage = editor.extensionStorage.aiChanges
const selectedchange = storage.getSelectedChange()
```

To select a change programmatically, use the `selectAiChange` command.

```ts
editor.commands.selectAiChange(changeId)
```

This will move the cursor to the beginning of the change, so that it is considered "selected".

The text of the selected change can be referenced in the `getCustomDecorations` function to apply custom styles to it.

## Customize the Change's Appearance

The `getCustomDecorations` option allows you to control the appearance of changes and provide visual cues to the user.

It receives these arguments:

- `change`: The change object that contains the information about the change.
- `changes`: A list of all found changes.
- `isSelected`: A boolean that indicates if the change is selected. A change is selected when the cursor is on top of it.
- `getDefaultDecorations`: A function that returns the default decorations for the change. If the `getCustomDecorations` function is not provided, the default decorations will be used.
- `editor`: The Editor instance.
- `previousDoc`: The previous document before the AI made changes. The changes are obtained by comparing the current document with this one.
- `currentDoc`: The current document after the AI made changes.

```ts
AiChanges.configure({
  getCustomDecorations({ change, isSelected, getDefaultDecorations }) {
    // You can combine the default decorations of the AI Changes extension with your custom ones
    const decorations = getDefaultDecorations()

    // Add a custom element after the inserted text of the change
    if (isSelected) {
      decorations.push(
        Decoration.widget(change.newRange.to, () => {
          const element = document.createElement('span')

          element.textContent = 'âœ…'
          return element
        }),
      )
    }
    return decorations
  },
})
```

The custom styles and elements are implemented with the [Prosemirror Decorations API](https://prosemirror.net/docs/ref/#view.Decorations).

To learn how to show a popover when you select a change, follow [this guide](/content-ai/capabilities/changes/features/display-changes#show-a-popover-when-you-select-a-change).

## Show a Popover When You Select a Change

In most user review workflows, you'll need to show a popover or a tooltip when you select a change. It provides additional information about the change and allows the user to accept or reject it.

To show a popover when you select a change, use the `getCustomDecorations` option. It allows you to add custom elements to the changes, including popovers.

Below is a simplified example using the React UI library.

```tsx
// First, define a hook to store the HTML element where the popover will be rendered
const [popoverElement, setPopoverElement] = useState<HTMLElement | null>(null)

AiChanges.configure({
  getCustomDecoration({ change, isSelected, getDefaultDecorations }) {
    const decorations = getDefaultDecorations()

    // Then, create a Prosemirror decoration that contains the HTML element
    Decoration.widget(change.newRange.to, () => {
      const element = document.createElement('span')

      return element
    })
    return decorations
  },
})

if (popoverElement) {
  const selectedChange = editor.extensionStorage.aiChanges.getSelectedChange()

  // Then, add the HTML content to the custom element. In this example, we use React Portals to render the popover.
  ReactDOM.createPortal(<Popover change={selectedChange} />, popoverElement)
}
```

We recommend using the [Floating UI](https://floating-ui.com/) library to display the popover. You can see an example on how to do it [in the demo](/content-ai/capabilities/changes/overview).

## Display changes in a sidebar outside the editor

You can access the current changes from the extension's [storage object](/content-ai/capabilities/change/api-reference#extension-storage).

```ts
const storage = editor.extensionStorage.aiChange
const changes = storage.getChanges()
```

Then, you can use this data to render changes in the UI, outside the editor. Here is an example of how to do it with the React UI library:

```tsx
// Get the changes from the Editor state.
const storage = editor.extensionStorage.aichange
const changes = storage.getchanges()

// Render the changes in the UI
return (
  <div>
    {changes.map((change) => (
      <div key={change.id}>
        <button onClick={() => editor.commands.acceptAiChange(change.id)}>Accept</button>
        <button onClick={() => editor.commands.rejectAiChange(change.id)}>Reject</button>
      </div>
    ))}
  </div>
)
```

## Hide and show changes

In some situations you might want to keep tracking the changes, but not show them. For example, when you are streaming AI-generated content. You can hide and show changes programmatically using the `setShowAiChanges` command.

```ts
// Hide changes
editor.commands.setShowAiChanges(false)

// Show changes
editor.commands.setShowAiChanges(true)
```
